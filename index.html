<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
  <link rel="stylesheet" type="text/css" href="css/normalize.css">
  <link rel="stylesheet" type="text/css" href="css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="css/custom-style.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
  <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery.scrollto@2.1.3/jquery.scrollTo.min.js"></script>
</head>
<style>
  .gridlines line {
    stroke: #bbb;
  }

  .gridlines .domain {
    stroke: none;
  }

  line.link {
    stroke: #222;
    stroke-width: 1px;
  }

  circle.node {
    stroke: black;
    stroke-width: 1px;
  }

  rect.activeRegion {
    fill: none;
    pointer-events: all;
  }

  line.avgline {
    stroke: black;
    stroke-width: 2px;
    stroke-dasharray: 8;
  }


  g.mouseover rect {
    fill: white;
    stroke: #222;
    stroke-width: 1px;
  }

  g.mouseover text {
    font-family: Arial, sans-serif;
  }

  g.mouseover text:first-child {
    font-weight: bold;
  }

  .state {
    fill: lightgrey;
  }

  .outline {
    stroke: black;
    stroke-width: 1px;
    fill: none;
  }

  .mouseover {
    stroke-width: 3px;
    pointer-events: none;
  }

  .graticule {
    fill: none;
    stroke: grey;
    stroke-width: 1px;
  }

  .my-legend .legend-title {
    text-align: left;
    margin-bottom: 8px;
    font-weight: bold;
    font-size: 90%;
  }

  .my-legend .legend-scale ul {
    margin: 0;
    padding: 0;
    float: left;
    list-style: none;
  }

  .my-legend .legend-scale ul li {
    display: block;
    float: left;
    width: 142px;
    margin-bottom: 6px;
    text-align: center;
    font-size: 80%;
    list-style: none;
  }

  .my-legend ul.legend-labels li span {
    display: block;
    float: left;
    height: 15px;
    width: 142px;
  }

  .my-legend a {
    color: #777;
  }

  .header {
    overflow: hidden;
    background-color: #f1f1f1;
    padding: 20px 10px;
  }

  .header a {
    float: left;
    color: black;
    text-align: center;
    padding: 12px;
    text-decoration: none;
    font-size: 18px;
    line-height: 25px;
    border-radius: 4px;
  }

  .header a.logo {
    font-size: 25px;
    font-weight: bold;
  }

  .header-right a:hover {
    background-color: #ddd;
    color: black;
  }


  .header-right {
    float: right;
  }

  @media screen and (max-width: 500px) {
    .header a {
      float: none;
      display: block;
      text-align: left;
    }

    .header-right {
      float: none;
    }
  }

  div.relative {
    position: relative;
    left: 10%;
    right: 10%;
    width: 80%;
  }

  input {
    display: inline-block;
    vertical-align: top;
  }

  .container-float {
    position: relative;
    width: 70%;
    height: 330;
    left: 15%;
    right: 15%;
    background-color: white;
    margin: 0;
  }

  .first {
    position: relative;
    height: 330;
    width: 550;
    float: left;
    background-color: white;
  }

  .second {
    position: relative;
    height: 330;
    width: 330;
    float: left;
    background-color: white;
  }

  .clear {
    clear: both;
  }
</style>

<body>
  <div class="header">
    <a class="logo">Vaccination Rate and Policital Inclination of US States</a>

    <div class="header-right">
      <a href="#pulldown-bar">Diagram1</a>
      <a href="#pulldown-bar2">Diagram2</a>
      <!-- <a href="#pulldown-bar2">Diagram3</a> -->
    </div>
  </div>

  <div class="relative">
    These diagrams reprsent the states' vaccination rates and political inclinations at the same time, in order to show
    the potential relationship between these factors. The color red represents Republican States and blue represents
    Democratic states, while grey represent states with little to no political inclination, based on the Cook Partisian
    Voting Index. The saturation of the colors represent the relative rate of vaccination, with deeper colors meaning
    higher number or percentage vaccinated.
    <div id="pulldown-bar">
      <select id="sort-select" style="width:400px;">
        <option value="sortTotalDose">Sort by Total Doses Delivered</option>
        <option value="sortDosePrecent" selected>Sort by Precent of Total Pop with at least One Dose</option>
        <option value="sortDosePrecentTwo">Sort by Precent of Total Pop fully Vaccinated</option>
        <option value="sortPVI">Sort by Cook Partisan Voting Index</option>
        <option value="sortAlpha">Sort by Alphabet</option>
      </select>
    </div>
  </div>
  <!-- <br>
  <a href="#choropleth">Click here to see the content below.</a>
  <br> -->

  <div style="text-align:center;">
    <svg id="chart" height="340" width="1000" style="margin-top:20px; margin-bottom:30px">
    </svg>
  </div>
  <div class="relative">
    <div class='my-legend'>
      <div class='legend-title'>Cook Partisan Voting Index Color Scale</div>
      <div class='legend-scale'>
        <ul class='legend-labels'>
          <li><span style='background:#B03A2E;'></span>less than -9</li>
          <li><span style='background:#E74C3C;'></span>-9 to -3</li>
          <li><span style='background:#F5B7B1;'></span>-3 to -1</li>
          <li><span style='background:#ABB2B9;'></span>0</li>
          <li><span style='background:#AED6F1;'></span>1 to 10</li>
          <li><span style='background:#3498DB;'></span>11 to 16</li>
          <li><span style='background:#2874A6;'></span> greater than 16 </li>
        </ul>
      </div>
    </div>
  </div>
  <div class="relative">
    <div id="pulldown-bar2">
      <select id="options" style="width:400px;">
        <option value="vaccineValue">Precent of Total Pop with at least One Dose</option>
        <option value="pviValue">Cook Partisan Voting Index</option>
        <option value="vaccineByPolitic" selected>Precent of Total Pop with at least One Dose (with Political
          Inclination)</option>
      </select>
    </div>
  </div>
  <div class="container-float">
    <div class="first">
      <svg id="choropleth" height="300" width="550" style="background: #fff; margin-top:10px">
      </svg>
    </div>

    <div class="second">
      <b>Choose a min value for Precent of Total Pop with at least One Dose (20-40)<br></b>
      <input type="range" id="volume" name="volume" min="20" max="40" style="margin-bottom:0px;">
      <b id="chosenNum"></b>
      <div class="filterAnalysis" style="margin-top:20px; margin-left: 20px;">
        <div id="blueNum"></div>
        <div id="redNum"></div>
        <div id="bluePercent"></div>
        <div id="redPercent"></div>
        <b id="range">with vaccine rate over 12</b>
      </div>
    </div>
    <div id="clear"></div>
  </div>
  <div class="relative" style="margin-top:10px; margin-bottom:20px;">
    <div class='legend-title legend2'>Precent of Total Pop with at least One Dose(%)</div>
    <svg id="map-legend-blue" width="1000" height="50" style="background: #fff; margin-bottom:0px"></svg>
    <svg id="map-legend-red" width="1000" height="50" style="background: #fff; margin-top:5px"></svg>
  </div>

  <script>
    // Setting for first chart
    const svg = d3.select("svg#chart");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 30, left: 60 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const mouseover = svg.append("g").attr("class", "mouseover")
      .attr("transform", `translate(${margin.left + 15},${margin.top + 0})`);
    let annotations = svg.append("g").attr("id", "annotations");
    let chartArea = svg.append("g").attr("id", "points")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Setting for second chart
    const svg2 = d3.select("svg#choropleth");
    const width2 = svg2.attr("width");
    const height2 = svg2.attr("height");
    const margin2 = { top: 20, right: 20, bottom: 20, left: 10 };
    const mapWidth = width2 - margin2.left - margin2.right;
    const mapHeight = height2 - margin2.top - margin2.bottom;
    const map = svg2.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    const requestData = async () => {
      // Data cleaning
      var redBlueData = await d3.csv("state_redBlue.csv", d3.autoType);
      var vaccineData = await d3.csv("covid19_vaccinations_in_the_united_states .csv", d3.autoType);
      var stateIDs = await d3.tsv("us-state-names.tsv", d3.autoType);
      merge_data = redBlueData;
      merge_data.forEach((d1, i) => {
        vaccineData.forEach((d2, i) => {
          if (d2.State === d1.State) {
            d1['Total Doses Delivered'] = d2['Total Doses Delivered']
            d1['Percent of Total Pop with at least One Dose by State of Residence'] = d2['Percent of Total Pop with at least One Dose by State of Residence']
            d1['Percent of Total Pop Fully Vaccinated by State of Residence'] = d2['Percent of Total Pop Fully Vaccinated by State of Residence']
          }
        });
        stateIDs.forEach((d3, i) => {
          if (d3.name == d1.State) {
            d1['Code'] = d3['code']
          }
        });

      });
      console.log("merge")
      console.log(merge_data)


      // Lollipop chart
      merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop with at least One Dose by State of Residence'], b['Percent of Total Pop with at least One Dose by State of Residence']));
      let dosesExten = d3.extent(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
      let dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
      let avgDose = d3.mean(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);

      const states = d3.map(merge_data, d => d.State)
      const stateScale = d3.scalePoint().domain(states).range([0, chartWidth])
        .padding(0.1);
      const codes = d3.map(merge_data, d => d.Code);
      const codeScale = d3.scalePoint().domain(codes).range([0, chartWidth])
        .padding(0.1);


      let leftAxis = d3.axisLeft(dosesScale).tickFormat(function (d) { return d + "%"; });

      let leftAxisG = annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
        .call(leftAxis);
      let bottomAxis = d3.axisBottom(codeScale)
      let bottomAxisG = annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
        .call(bottomAxis);

      let midline = chartArea.selectAll("line.avgline").data(merge_data)
        .join(
          enter => enter.append("line")
            .attr("class", "avgline")
        )
        .attr("x1", 0)
        .attr("x2", chartWidth + 10)
        .attr("y1", dosesScale(avgDose))
        .attr("y2", dosesScale(avgDose));
      let rec = chartArea.selectAll("rect.activeRegion").data(merge_data)
        .join(
          enter => enter.append("rect")
            .attr("class", "activeRegion")
            .attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("width", 20)
            .attr("fill", "none")
        )
      let lines = chartArea.selectAll("line.link").data(merge_data)
        .join(
          enter => enter.append("line")
            .attr("class", "link")
            .attr("stroke", "#333")
        )
        .attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
        .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence']));

      let circles = chartArea.selectAll("circle.node").data(merge_data)
        .join(
          enter => enter.append("circle")
            .attr("class", "node")
            .attr("r", 6)
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("id", d => `${d.State}`)
            .attr("fill", d => {
              if (d.pvi <= -10) {
                return "#2874A6";
              } else if (d.pvi <= -3) {
                return "#3498DB";
              }
              else if (d.pvi < 0) {
                return "#AED6F1";
              } else if (d.pvi >= 17) {
                return "#B03A2E";
              } else if (d.pvi >= 11) {
                return "#E74C3C";
              } else if (d.pvi > 0) {
                return "#F5B7B1";
              }
              else {
                return "#ABB2B9";
              }
            })
        )
        .attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])})`);

      // Map
      const us = await d3.json("us-smaller.json");
      var statesFeature = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], statesFeature);
      var path = d3.geoPath().projection(projection);
      console.log(statesFeature);
      var graticule = d3.geoGraticule10();
      console.log(us);
      map.append("path").attr("class", "graticule").attr("d", path(graticule))
      let state = map.selectAll("path.state").data(statesFeature.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path);
      let mesh = map.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      // Generate data for map color
      let idToState = {};
      let pviData = {};
      let percentData = {};
      stateIDs.forEach(row => {
        idToState[row.id] = row.name;
        pviData[row.name] = 0;
        percentData[row.name] = 0;
      });
      merge_data.forEach((d, i) => {
        pviData[d.State] = d.pvi;
        percentData[d.State] = d['Percent of Total Pop with at least One Dose by State of Residence'];
      });
      console.log(pviData);
      const percentExtent = d3.extent(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
      console.log(percentExtent);
      const blueScale = d3.scaleLinear().domain(percentExtent).range(["#f1f8fd", "#2874A6"]);
      const redScale = d3.scaleLinear().domain(percentExtent).range(["#fef7f7", "#B03A2E"]);
      const colorScale = d3.scaleQuantile().domain(Object.values(percentData)).range(["#fff", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"])
      state.style("fill", d => {
        if (percentData[idToState[d.id]] == 0) return "#ffffff";
        else if (pviData[idToState[d.id]] < 0) return blueScale(percentData[idToState[d.id]]);
        else if (pviData[idToState[d.id]] > 0) return redScale(percentData[idToState[d.id]]);
        else return "gray";
      });
      const blueLine = d3.select("svg#map-legend-blue").append("g")
        .attr("class", "legendLinear");
      const legendBlue = d3.legendColor()
        .shapeWidth(100)
        .cells(10)
        .orient('horizontal')
        .scale(blueScale);
      blueLine.call(legendBlue);
      const redLine = d3.select("svg#map-legend-red").append("g")
        .attr("class", "legendLinear");
      const legendRed = d3.legendColor()
        .shapeWidth(100)
        .cells(10)
        .orient('horizontal')
        .scale(redScale);
      redLine.call(legendRed);

      // Animation
      // Event handler 1: Update mouse over for lollipop chart
      function stringLen(str) {
        const dummytext = mouseover.append("text").attr("class", "legendtext").attr("visibility", "hidden");
        dummytext.text(str)
        let len = dummytext.node().getComputedTextLength()
        dummytext.remove()
        return len;
      }
      const frame = mouseover.append("rect").attr("class", "frame")
        .attr("x", 0).attr("y", 0)
        .attr("rx", 5).attr("ry", 5)
        .attr("height", 130);
      const textbox = mouseover.append("g").attr("transform", "translate(10,10)");
      const format = d3.format(',d');
      function updateMouseover(d) {
        textbox.html('');
        let res = ""
        if (d['pvi'] > 0) {
          res = "Republican"
        } else if (d['pvi'] < 0) {
          res = "Democratic"
        } else {
          res = "Both"
        }
        let stateName = `State: ${d['State']}`;
        let pvi = `Cook Partisan Voting Index: ${format(d['pvi'])}`
        let voteres = "Voting Result: " + res;
        let totalD = `Total Doses Delivered: ${format(d['Total Doses Delivered'])}`
        let onepren = `Percent of Total Pop with at least One Dose by State of Residence: ${format(d['Percent of Total Pop with at least One Dose by State of Residence'])}`
        let twopren = `Percent of Total Pop Fully Vaccinated by State of Residence: ${format(d['Percent of Total Pop Fully Vaccinated by State of Residence'])}`
        let maxWidth = Math.max(stringLen(stateName), stringLen(totalD), stringLen(onepren), stringLen(twopren))
        frame.attr("width", maxWidth + 20);

        textbox.append("text").text(stateName)
          .attr("x", 0).attr("y", 10);
        textbox.append("text").text(pvi)
          .attr("x", 0).attr("y", 30);
        textbox.append("text").text(voteres)
          .attr("x", 0).attr("y", 50);
        textbox.append("text").text(totalD)
          .attr("x", 0).attr("y", 70);
        textbox.append("text").text(onepren)
          .attr("x", 0).attr("y", 90);
        textbox.append("text").text(twopren)
          .attr("x", 0).attr("y", 110);

      }
      // Event handler 2: Update mouse over for map
      let tooltipWidth = 130;
      let tooltipHeight = 60;
      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");
      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2);
      let txt2 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 22);
      let txt3 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 42);
      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .attr("d", "");

      function mouseEntersPlot(d) {
        tooltip.style("visibility", "visible");
        let state = d3.select(d);
        let stateID = state.datum().id;
        console.log(state.datum())

        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });
        momesh.datum(mo).attr("d", path)
        txt.text(idToState[stateID]);
        txt2.text(`pvi value: ${pviData[idToState[stateID]]}`);
        txt3.text(`vaccine rate: ${percentData[idToState[stateID]]}`)
        let bounds = path.bounds(state.datum());
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1];
        tooltip.attr("transform", `translate(${xPos},${yPos})`);
      }
      function mouseLeavesPlot(d) {
        tooltip.style("visibility", "hidden");
        let state = d3.select(d);
        momesh.attr("d", "");
      }

      // Mouse over handling
      circles.on("mouseover", function (d) {
        mouseover.attr("visibility", "");
        d3.select(this).transition().duration(200)
          .attr("r", 10)
          .attr("stroke", "black")
          .attr("stroke-width", 4);
        updateMouseover(d3.select(this).datum())
        let stateName = d3.select(this).datum().State;
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseEntersPlot(this);
          }
        })
      });

      circles.on("mouseout", function () {
        mouseover.attr("visibility", "hidden");
        d3.select(this).transition().duration(200)
          .attr("r", 6)
          .attr("stroke", "black")
          .attr("stroke-width", 4);
        let stateName = d3.select(this).datum().State;
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseLeavesPlot(this);
          }
        })
      });
      rec.on("mouseover", function (d) {
        mouseover.attr("visibility", "");
        updateMouseover(d3.select(this).datum())
        let stateName = d3.select(this).datum().State;
        let circleTarget = d3.select(`circle#${stateName}`);
        circleTarget.transition().duration(200).attr("r", 10);
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseEntersPlot(this);
          }
        })
      });

      rec.on("mouseout", function () {
        mouseover.attr("visibility", "hidden");
        let stateName = d3.select(this).datum().State;
        let circleTarget = d3.select(`circle#${stateName}`);
        circleTarget.transition().duration(200).attr("r", 6);
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseLeavesPlot(this);
          }
        })
      });

      state.on("mouseenter", function (d) {
        mouseEntersPlot(this);
        mouseover.attr("visibility", "");
        let ID = d3.select(this).datum().id;
        circles.each(function () {
          let element = d3.select(this).datum()
          if (element.State == idToState[ID]) {
            updateMouseover(element);
            d3.select(this).transition().duration(200).attr("r", 10);
          }
        })
      });
      state.on("mouseout", function (d) {
        mouseLeavesPlot(this);
        let ID = d3.select(this).datum().id;
        mouseover.attr("visibility", "hidden");
        circles.each(function () {
          let element = d3.select(this).datum()
          if (element.State == idToState[ID]) {
            d3.select(this).transition().duration(200).attr("r", 6);
          }
        })
      });


      // Dealing with sorting options for lollipop chart
      d3.select("#sort-select").on("change", function () {

        var option = d3.select(this).property("value")
        var data;
        if (option === "sortPVI") {
          merge_data.sort((a, b) => d3.ascending(a['pvi'], b['pvi']))
          const pviExtent = d3.extent(merge_data, d => d['pvi']);
          console.log(pviExtent)
          const avgPvi = 0; //d3.mean(merge_data, d => d['pvi']);
          const pviDist = Math.max(Math.abs(pviExtent[0] - avgPvi), Math.abs(pviExtent[1] - avgPvi));

          const adjustedPviExtent = [avgPvi - pviDist, avgPvi + pviDist];
          const pviScale = d3.scaleLinear().domain(adjustedPviExtent).range([chartHeight, 0]);
          data = merge_data;
          console.log(merge_data)
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis);
          leftAxis.scale(pviScale).tickFormat(d3.format("~f"));
          leftAxisG.transition().call(leftAxis);

          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", pviScale(avgPvi)).attr("y2", pviScale(avgPvi));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${pviScale(d['pvi'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(pviScale(avgPvi), pviScale(d['pvi'])))
            .attr("height", d => Math.abs(pviScale(avgPvi) - pviScale(d['pvi'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", pviScale(avgPvi)).attr("y2", d => pviScale(d['pvi']));
        }
        if (option === "sortAlpha") {
          merge_data.sort((a, b) => d3.ascending(a['State'], b['State']));
          data = merge_data;
          const pviExtent = d3.extent(merge_data, d => d['pvi']);
          console.log(pviExtent)
          const avgPvi = 0; //d3.mean(merge_data, d => d['pvi']);
          const pviDist = Math.max(Math.abs(pviExtent[0] - avgPvi), Math.abs(pviExtent[1] - avgPvi));

          const adjustedPviExtent = [avgPvi - pviDist, avgPvi + pviDist];
          const pviScale = d3.scaleLinear().domain(adjustedPviExtent).range([chartHeight, 0]);
          console.log(merge_data)
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis);
          leftAxis.scale(pviScale).tickFormat(d3.format("~f"));
          leftAxisG.transition().call(leftAxis);

          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", pviScale(avgPvi)).attr("y2", pviScale(avgPvi));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${pviScale(d['pvi'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(pviScale(avgPvi), pviScale(d['pvi'])))
            .attr("height", d => Math.abs(pviScale(avgPvi) - pviScale(d['pvi'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", pviScale(avgPvi)).attr("y2", d => pviScale(d['pvi']));
        }
        else if (option === "sortTotalDose") {
          merge_data.sort((a, b) => d3.ascending(a['Total Doses Delivered'], b['Total Doses Delivered']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Total Doses Delivered']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLog().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Total Doses Delivered']);

          leftAxis.scale(dosesScale).tickFormat(d3.format(".2s"));
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Total Doses Delivered'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Total Doses Delivered'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Total Doses Delivered'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Total Doses Delivered']));

        }
        else if (option === "sortDosePrecent") {
          merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop with at least One Dose by State of Residence'], b['Percent of Total Pop with at least One Dose by State of Residence']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
          leftAxis.scale(dosesScale).tickFormat(function (d) { return d + "%"; });
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence']));
        }
        else if (option === "sortDosePrecentTwo") {
          merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop Fully Vaccinated by State of Residence'], b['Percent of Total Pop Fully Vaccinated by State of Residence']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Percent of Total Pop Fully Vaccinated by State of Residence']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Percent of Total Pop Fully Vaccinated by State of Residence']);
          leftAxis.scale(dosesScale).tickFormat(function (d) { return d + "%"; });
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence']));
        }

      })

      // Dealing with sorting options for map
      d3.select("#options").on("change", function () {
        var option = d3.select(this).property("value")
        console.log(option)
        var data;
        if (option === "pviValue") {
          optionControl = "pviValue";
          document.querySelector('div.legend2').innerText = "Cook Partisan Voting Index By State (same scale as above)";
          d3.select("svg#map-legend-red").attr("visibility", "hidden");
          d3.select("svg#map-legend-blue").attr("visibility", "hidden");
          state.style("fill", d => {
            let pviValue = pviData[idToState[d.id]];
            console.log(pviValue);
            if (pviValue <= -10) {
              return "#B03A2E";
            } else if (pviValue <= -3) {
              return "#E74C3C";
            }
            else if (pviValue < 0) {
              return "#F5B7B1";
            } else if (pviValue >= 17) {
              return "#2874A6";
            } else if (pviValue >= 11) {
              return "#3498DB";
            } else if (pviValue > 0) {
              return "#AED6F1";
            }
            else {
              return "#ABB2B9";
            }
          })
        }
        else if (option === "vaccineValue") {
          optionControl = "vaccineValue";
          updateFilter(numControl);
          document.querySelector('div.legend2').innerText = "Precent of Total Pop with at least One Dose(%)";
          d3.select("svg#map-legend-red").attr("visibility", "hidden");
          d3.select("svg#map-legend-blue").attr("visibility", "");
          const legendPurple = d3.legendColor()
            .shapeWidth(200)
            .cells(10)
            .orient('horizontal')
            .scale(colorScale);
          blueLine.call(legendPurple);
          state.style("fill", d => colorScale(percentData[idToState[d.id]]));
        }
        else if (option === "vaccineByPolitic") {
          optionControl = "vaccineByPolitic";
          updateFilter(numControl);
          document.querySelector('div.legend2').innerText = "Precent of Total Pop with at least One Dose(%)";
          d3.select("svg#map-legend-red").attr("visibility", "");
          d3.select("svg#map-legend-blue").attr("visibility", "");
          blueLine.call(legendBlue);
          state.style("fill", d => {
            if (percentData[idToState[d.id]] == 0) return "#ffffff";
            else if (pviData[idToState[d.id]] < 0) return blueScale(percentData[idToState[d.id]]);
            else if (pviData[idToState[d.id]] > 0) return redScale(percentData[idToState[d.id]]);
            else return "gray";
          });
        }
      })

      // Do some counting for user
      let redNumTotal = 0;
      let blueNumTotal = 0;
      merge_data.forEach((d, i) => {
        if (d.pvi < 0) blueNumTotal = blueNumTotal + 1;
        else if (d.pvi > 0) redNumTotal = redNumTotal + 1;
      })
      let optionControl = "vaccineByPolitic";
      let numControl = 23;
      function updateFilter(num) {
        numControl = num;
        let redNum = 0;
        let blueNum = 0;
        document.querySelector('b#chosenNum').innerText = `${num}`;
        merge_data.forEach((d, i) => {
          if (d['Percent of Total Pop with at least One Dose by State of Residence'] > num) {
            if (d.pvi < 0) blueNum = blueNum + 1;
            else if (d.pvi > 0) redNum = redNum + 1;
          }
          document.querySelector('div#blueNum').innerText = `Number of Democratic states: ${blueNum}`;
          document.querySelector('div#redNum').innerText = `Number of Republican states: ${redNum}`;
          document.querySelector('div#bluePercent').innerText = `Percent of total Democratic states: ${format(100 * blueNum / blueNumTotal)} %`;
          document.querySelector('div#redPercent').innerText = `Percent of total Republican states: ${format(100 * redNum / redNumTotal)} %`;
          document.querySelector('b#range').innerText = `with vaccine rate over ${num}`;
        })
        if (optionControl === "vaccineByPolitic") {
          state.style("fill", d => {
            if (percentData[idToState[d.id]] < num) return "#ffffff";
            if (percentData[idToState[d.id]] == 0) return "#ffffff";
            else if (pviData[idToState[d.id]] < 0) return blueScale(percentData[idToState[d.id]]);
            else if (pviData[idToState[d.id]] > 0) return redScale(percentData[idToState[d.id]]);
            else return "gray";
          });
        }
        else if (optionControl === "vaccineValue") {
          state.style("fill", d => {
            if (percentData[idToState[d.id]] < num) return "#ffffff";
            else return colorScale(percentData[idToState[d.id]]);
          });
        }

      }
      updateFilter(23);
      const input = document.querySelector('input');
      const log = document.getElementById('volume');
      input.addEventListener('input', updateValue);
      function updateValue(evt) {
        // console.log(log.valueAsNumber);
        updateFilter(log.valueAsNumber);
      }
    }

    requestData();
  </script>

</body>

</html>