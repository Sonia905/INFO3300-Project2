<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
  <link rel="stylesheet" type="text/css" href="css/normalize.css">
  <link rel="stylesheet" type="text/css" href="css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="css/custom-style.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
  <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery.scrollto@2.1.3/jquery.scrollTo.min.js"></script>
</head>
<style>
  body {
    zoom: 72%;
  }

  .gridlines line {
    stroke: #bbb;
  }

  .gridlines .domain {
    stroke: none;
  }

  line.link {
    stroke: #222;
    stroke-width: 1px;
  }

  rect.activeRegion {
    fill: none;
    pointer-events: all;
  }

  .question_rec {
    fill: none;
    pointer-events: all;
    stroke: white;
  }

  line.avgline {
    stroke: black;
    stroke-width: 2px;
    stroke-dasharray: 8;
  }


  g.mouseover rect {
    stroke: #222;
    stroke-width: 1px;
  }

  g.mouseover text {
    font-family: Arial, sans-serif;
  }

  g.mouseover text:first-child {
    font-weight: bold;
  }

  .state {
    fill: lightgrey;
  }

  .outline {
    stroke: black;
    stroke-width: 1px;
    fill: none;
  }

  .mouseover {
    stroke-width: 3px;
    pointer-events: none;
  }

  .question_mark {
    pointer-events: all;
  }

  .graticule {
    fill: none;
    stroke: grey;
    stroke-width: 1px;
  }

  body {
    margin: 0;
  }

  .navbar {
    overflow: hidden;
    background-color: black;
    /* position: fixed; */
    top: 0;
    width: 100%;
    z-index: 999;
    height: 70px;
  }

  .navbar-right {
    float: right;
  }

  .navbar a.logo {
    font-size: 25px;
    font-weight: bold;
  }

  .navbar a {
    float: left;
    display: block;
    color: #f2f2f2;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
    font-size: 17px;
    border-radius: 4px;
    line-height: 40px;
  }

  .navbar-right a:hover {
    background: #ddd;
    color: black;
  }


  .main {
    padding: 16px;
    margin-top: 60px;
  }

  div.part1 {
    background: white;
  }

  div.relative {
    position: relative;
    left: 10%;
    right: 10%;
    width: 80%;
  }

  div.decription {
    font-size: 17px;
    border-style: solid;
    border-color: black;
    padding-left: 25px;
    padding-right: 25px;
    padding-top: 20px;
    padding-bottom: 20px;
    border-radius: 18px;
    border-width: thin;
  }

  input {
    display: inline-block;
    vertical-align: top;
  }

  .lolipop-float {
    position: relative;
    width: 1350px;
    height: 330;
    background-color: white;
    margin: 0;
    margin: auto;
  }

  .first-loli {
    position: relative;
    height: 330;
    width: 950;
    float: left;
    background-color: white;
  }

  .second-loli {
    position: relative;
    height: 330;
    width: 300;
    float: left;
    background-color: white;
  }

  .foreground {
    fill: #FDE79A;
  }

  .foreground2 {
    fill: #FEC26D;
  }

  .pie-background {
    fill: lightgrey;
  }

  .container-float {
    position: relative;
    width: 880px;
    height: 330;
    background-color: white;
    margin: 0;
    margin: auto;
  }

  .first {
    position: relative;
    height: 330;
    width: 550;
    float: left;
    background-color: white;
  }

  .second {
    position: relative;
    height: 330;
    width: 330;
    float: left;
    background-color: white;
  }

  .clear {
    clear: both;
  }

  input {
    margin-bottom: 0;
  }
</style>

<body>
  <div class="navbar">
    <a class="logo">Vaccination Rate and Policital Inclination of US States</a>
    <div class="navbar-right">
      <a href="#jumper">Diagram1</a>
      <a href="#pulldown-bar2">Diagram2</a>
    </div>
  </div>


  <div class="part1">
    <div class="main">
      <div class="relative">
        <br>
        <div class="decription" id="jumper">
          These diagrams reprsent the states' vaccination rates and political inclinations at the same time, in order to
          show
          the potential relationship between these factors. The color red represents Republican States and blue
          represents
          Democratic states, while grey represent battleground states, based on the Cook PartisianVoting Index.
          The saturation of the colors represent the relative rate of vaccination, with deeper colors meaning
          higher number or percentage vaccinated.
        </div>
        <br>
        <div id="pulldown-bar">
          <select id="sort-select" style="width:450px;">
            <option value="sortTotalDose">Sort by Total Doses Delivered (Y-axis)</option>
            <option value="sortDosePrecent" selected>Sort by Precent of Total Pop with at least One Dose (Y-axis)
            </option>
            <option value="sortDosePrecentTwo">Sort by Precent of Total Pop fully Vaccinated (Y-axis)</option>
            <option value="sortPVI">Sort X-axis by Cook Partisan Voting Index (Y-axis least One Dose)</option>
            <!-- <option value="sortAlpha">Sort by Alphabet</option> -->
          </select>
        </div>
      </div>

      <div class="lolipop-float">
        <div class="first-loli">
          <svg id="chart" height="340" width="950" style="margin-top:10px; margin-bottom:10px">
          </svg>
        </div>
        <div class="second-loli">
          <svg id="loli-hover" height="400" width="400" style="margin-top:10px; margin-bottom:10px">
        </div>
      </div>
      <br>
      <br>
      <div class="relative">
        <div class='legend-title legend1'>Cook Partisan Voting Index Color Scale</div>
        <svg id="lolipop-legend" width="1500" height="50" style="background: #fff; margin-bottom:0px"></svg>
      </div>
    </div>
  </div>
  <div class="relative">
    <div id="pulldown-bar2">
      <select id="options" style="width:400px;">
        <option value="vaccineValue">Precent of Total Pop with at least One Dose</option>
        <option value="pviValue">Degree of Political Inclination (based on Cook Partisan Voting Index)</option>
        <option value="vaccineByPolitic" selected>Precent of Total Pop with at least One Dose (with Political
          Inclination)</option>
      </select>
    </div>
  </div>
  <div class="container-float">
    <div class="first">
      <svg id="choropleth" height="300" width="550" style="background: #fff; margin-top:0px">
      </svg>
    </div>

    <div class="second">
      <b>Choose a minimum percentage of Total Pop with at least One Dose (20-40)<br></b>
      <input type="range" id="volume" name="volume" min="20" max="40" style="margin-bottom:0px;">
      <b id="chosenNum"></b>
      <div class="filterAnalysis" style="margin-top:20px; margin-left: 20px;">
        <div id="blueNum"></div>
        <div id="redNum"></div>
        <div id="bluePercent"></div>
        <div id="redPercent"></div>
        <b id="range">with vaccine rate over 12</b>
      </div>
    </div>
    <div id="clear"></div>
  </div>
  <div class="relative" style="margin-top:10px; margin-bottom:20px;">
    <div class='legend-title legend2'>Precent of Total Pop with at least One Dose(%)</div>
    <svg id="map-legend-blue" width="1000" height="50" style="background: #fff; margin-bottom:0px"></svg>
    <svg id="map-legend-red" width="1000" height="50" style="background: #fff; margin-top:5px"></svg>
  </div>

  <script>
    // Setting for first chart
    const svg = d3.select("svg#chart");
    const loli_hover = d3.select("svg#loli-hover");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 30, left: 60 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const mouseover = loli_hover.append("g").attr("class", "mouseover")
      .attr("transform", `translate(20,${margin.top + 0})`);
    let annotations = svg.append("g").attr("id", "annotations");
    let chartArea = svg.append("g").attr("id", "points")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Setting for second chart
    const svg2 = d3.select("svg#choropleth");
    const width2 = svg2.attr("width");
    const height2 = svg2.attr("height");
    const margin2 = { top: 20, right: 20, bottom: 20, left: 10 };
    const mapWidth = width2 - margin2.left - margin2.right;
    const mapHeight = height2 - margin2.top - margin2.bottom;
    const map = svg2.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    const requestData = async () => {
      // Data cleaning
      var redBlueData = await d3.csv("state_redBlue.csv", d3.autoType);
      var vaccineData = await d3.csv("covid19_vaccinations_in_the_united_states .csv", d3.autoType);
      var stateIDs = await d3.tsv("us-state-names.tsv", d3.autoType);
      merge_data = redBlueData;
      merge_data.forEach((d1, i) => {
        vaccineData.forEach((d2, i) => {
          if (d2.State === d1.State) {
            d1['Total Doses Delivered'] = d2['Total Doses Delivered']
            d1['Percent of Total Pop with at least One Dose by State of Residence'] = d2['Percent of Total Pop with at least One Dose by State of Residence']
            d1['Percent of Total Pop Fully Vaccinated by State of Residence'] = d2['Percent of Total Pop Fully Vaccinated by State of Residence']
          }
        });
        stateIDs.forEach((d3, i) => {
          if (d3.name == d1.State) {
            d1['Code'] = d3['code']
          }
        });

      });
      console.log("merge")
      console.log(merge_data)


      // Lollipop chart
      merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop with at least One Dose by State of Residence'], b['Percent of Total Pop with at least One Dose by State of Residence']));
      let dosesExten = d3.extent(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
      let dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
      let avgDose = d3.mean(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);

      const states = d3.map(merge_data, d => d.State)
      const stateScale = d3.scalePoint().domain(states).range([0, chartWidth])
        .padding(0.1);
      const codes = d3.map(merge_data, d => d.Code);
      const codeScale = d3.scalePoint().domain(codes).range([0, chartWidth])
        .padding(0.1);


      let leftAxis = d3.axisLeft(dosesScale).tickFormat(function (d) { return d + "%"; });

      let leftAxisG = annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
        .call(leftAxis);
      let bottomAxis = d3.axisBottom(codeScale)
      let bottomAxisG = annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
        .call(bottomAxis);

      let midline = chartArea.selectAll("line.avgline").data(merge_data)
        .join(
          enter => enter.append("line")
            .attr("class", "avgline")
        )
        .attr("x1", 0)
        .attr("x2", chartWidth + 10)
        .attr("y1", dosesScale(avgDose))
        .attr("y2", dosesScale(avgDose));
      let rec = chartArea.selectAll("rect.activeRegion").data(merge_data)
        .join(
          enter => enter.append("rect")
            .attr("class", "activeRegion")
            .attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("width", 20)
            .attr("fill", "none")
        )
      let lines = chartArea.selectAll("line.link").data(merge_data)
        .join(
          enter => enter.append("line")
            .attr("class", "link")
            .attr("stroke", "#333")
        )
        .attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
        .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence']));

      let circles = chartArea.selectAll("circle.node").data(merge_data)
        .join(
          enter => enter.append("circle")
            .attr("class", "node")
            .attr("r", 6)
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("id", d => `${d.State}`)
            .attr("fill", d => {
              if (d.pvi <= -10) {
                return "#2874A6";
              } else if (d.pvi <= -3) {
                return "#3498DB";
              }
              else if (d.pvi < 0) {
                return "#AED6F1";
              } else if (d.pvi >= 17) {
                return "#B03A2E";
              } else if (d.pvi >= 11) {
                return "#E74C3C";
              } else if (d.pvi > 0) {
                return "#F5B7B1";
              }
              else {
                return "#ABB2B9";
              }
            })
        )
        .attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])})`);

      // Map
      const us = await d3.json("us-smaller.json");
      var statesFeature = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], statesFeature);
      var path = d3.geoPath().projection(projection);
      console.log(statesFeature);
      var graticule = d3.geoGraticule10();
      console.log(us);
      map.append("path").attr("class", "graticule").attr("d", path(graticule))
      let state = map.selectAll("path.state").data(statesFeature.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path);
      let mesh = map.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      // Generate data for map color
      // create dictionary for map state name to data value
      let idToState = {};
      let pviData = {};
      let percentData = {};
      stateIDs.forEach(row => {
        idToState[row.id] = row.name;
        pviData[row.name] = 0;
        percentData[row.name] = 0;
      });
      merge_data.forEach((d, i) => {
        pviData[d.State] = d.pvi;
        percentData[d.State] = d['Percent of Total Pop with at least One Dose by State of Residence'];
      });
      console.log(pviData);
      // scale
      const percentExtent = d3.extent(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
      console.log(percentExtent);
      // two scale for option=vaccineByPolitic, the more saturate means the higher the vaccine rate. So two scale for different color
      const blueScale = d3.scaleLinear().domain(percentExtent).range(["#f1f8fd", "#2874A6"]);
      const redScale = d3.scaleLinear().domain(percentExtent).range(["#fef7f7", "#B03A2E"]);
      // one scale for option=vaccineValue
      const colorScale = d3.scaleQuantile().domain(Object.values(percentData)).range(["#fff", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"])
      // lolipop pvi scale
      const Loliscale = d3.scaleThreshold().domain([-9, -3, -1, 1, 10, 16, 25]).range(["#2874A6", "#3498DB", "#AED6F1", "#ABB2B9", "#F5B7B1", "#E74C3C", "#B03A2E"])
      state.style("fill", d => {
        if (percentData[idToState[d.id]] == 0) return "#ffffff";
        else if (pviData[idToState[d.id]] < 0) return blueScale(percentData[idToState[d.id]]);
        else if (pviData[idToState[d.id]] > 0) return redScale(percentData[idToState[d.id]]);
        else return "gray";
      });
      // create red and blue legend
      //const Loliscale = d3.scaleThreshold().domain(Object.values(pviData)).range(["#2874A6","#3498DB","#AED6F1","#ABB2B9","#F5B7B1","#E74C3C","#B03A2E"])
      const lolipopLine = d3.select("svg#lolipop-legend").append("g")
        .attr("class", "legendLinear");
      const legendLoli = d3.legendColor()
        .shapeWidth(175)
        .cells(10)
        .orient('horizontal')
        .labels(d3.legendHelpers.thresholdLabels)
        .scale(Loliscale);
      lolipopLine.call(legendLoli);
      const blueLine = d3.select("svg#map-legend-blue").append("g")
        .attr("class", "legendLinear");
      const legendBlue = d3.legendColor()
        .shapeWidth(100)
        .cells(10)
        .orient('horizontal')
        .scale(blueScale);
      blueLine.call(legendBlue);
      const redLine = d3.select("svg#map-legend-red").append("g")
        .attr("class", "legendLinear");
      const legendRed = d3.legendColor()
        .shapeWidth(100)
        .cells(10)
        .orient('horizontal')
        .scale(redScale);
      redLine.call(legendRed);

      // Animation
      // Event handler 1: Update mouse over for lollipop chart
      // function stringLen(str) {
      //   const dummytext = mouseover.append("text").attr("class", "legendtext").attr("visibility", "hidden");
      //   dummytext.text(str)
      //   let len = dummytext.node().getComputedTextLength()
      //   dummytext.remove()
      //   return len;
      // }
      const frame = mouseover.append("rect").attr("class", "frame")
        .attr("x", 0).attr("y", 0)
        .attr("rx", 5).attr("ry", 5)
        .attr("fill", "white")
        .attr("height", 350)
        .attr("width", 300);
      const textbox = mouseover.append("g").attr("transform", "translate(10,10)");
      textbox.append("text").text("Hover a Circle")
        .attr("x", 60).attr("y", 100).attr("font-size", "25px");
      textbox.append("text").text("to see more details")
        .attr("x", 40).attr("y", 150).attr("font-size", "25px");
      const format = d3.format(',d');
      function updateMouseover(d) {
        textbox.html('');
        let res = ""
        if (d['pvi'] > 0) {
          res = "Republican"
        } else if (d['pvi'] < 0) {
          res = "Democratic"
        } else {
          res = "Both"
        }
        let stateName = `${d['State']}`;
        let pvi = "Voting Index"
        let pvires = `${format(d['pvi'])}`;
        let vote = "Voting Result ";
        let voteres = res;
        let totalD = `${format(d['Total Doses Delivered'])}`
        let onepren = d['Percent of Total Pop with at least One Dose by State of Residence'];
        let twopren = d['Percent of Total Pop Fully Vaccinated by State of Residence'];
        let oneprenText = `${format(d['Percent of Total Pop with at least One Dose by State of Residence'])}` + "%";
        let twoprenText = `${format(d['Percent of Total Pop Fully Vaccinated by State of Residence'])}` + "%";
        //let maxWidth = Math.max(stringLen(stateName), stringLen(totalD), stringLen(onepren), stringLen(twopren))
        frame.attr("width", 300);
        var imgs = textbox.selectAll("image").data([0]);
        imgs.enter()
          .append("svg:image")
          .attr("class", "question_mark")
          .attr("xlink:href", "question-mark-icon.png")
          .attr("x", "86")
          .attr("y", "48")
          .attr("width", "15")
          .attr("height", "15");
        var rec_for_hhover = textbox.append("rect")
          .attr("class", "question_rec")
          .attr("x", 86)
          .attr("y", 48)
          .attr("width", 15)
          .attr("height", 15)
          .attr("visibility", "hidden");
        const question_hover = loli_hover.append("g").attr("class", "mouseover")
          .attr("transform", "translate(" + 40 + "," + 95 + ")");
        const question_frame = question_hover.append("rect").attr("class", "frame")
          .attr("x", 0).attr("y", 0)
          .attr("rx", 5).attr("ry", 5)
          .attr("fill", "white")
          .attr("height", 210);
        const question_explain = question_hover.append("g").attr("transform", "translate(10,10)");
        function updateQuestion() {
          question_explain.html('');
          question_frame.attr("width", 260);
          question_explain.append("text").text("The Cook Partisan Voting Index")
            .attr("x", 0).attr("y", 10);
          question_explain.append("text").text("(abbreviated CPVI or PVI)")
            .attr("x", 0).attr("y", 30).attr("font-weight", 900);
          question_explain.append("text").text("United States congressional district")
            .attr("x", 0).attr("y", 80);
          question_explain.append("text").text("is a measurement of how strongly a")
            .attr("x", 0).attr("y", 60);
          question_explain.append("text").text("or state leans toward the Democratic")
            .attr("x", 0).attr("y", 100);
          question_explain.append("text").text(" or Republican Party, compared to the")
            .attr("x", 0).attr("y", 120);
          question_explain.append("text").text("nation as a whole, based on how that")
            .attr("x", 0).attr("y", 140);
          question_explain.append("text").text("district or state voted in the previous")
            .attr("x", 0).attr("y", 160);
          question_explain.append("text").text("two Presidential elections.")
            .attr("x", 0).attr("y", 180);
          //  compared to the nation as a whole, based on how that district or state voted in the previous two Presidential elections
        }
        rec_for_hhover.on("mouseover", function (d) {
          question_hover.attr("visibility", "");
          updateQuestion()
        });

        rec_for_hhover.on("mouseout", function () {
          question_hover.attr("visibility", "hidden");
        });

        textbox.append("text").text(stateName)
          .attr("x", 0).attr("y", 20).attr("font-size", "25px");
        textbox.append("text").text(pvi)
          .attr("x", 0).attr("y", 60)
        textbox.append("text").text(pvires)
          .attr("x", 150).attr("y", 58).attr("font-weight", 900).attr("font-size", "18px");
        textbox.append("text").text(vote)
          .attr("x", 0).attr("y", 83);
        textbox.append("text").text(voteres)
          .attr("x", 150).attr("y", 81).attr("font-weight", 900).attr("font-size", "18px");
        textbox.append("text").text("Total Doess")
          .attr("x", 0).attr("y", 100);
        textbox.append("text").text("Delivered")
          .attr("x", 0).attr("y", 120);
        textbox.append("text").text(totalD)
          .attr("x", 150).attr("y", 110).attr("font-weight", 900).attr("font-size", "18px");
        textbox.append("text").text("Precent of Pop by State of Resdidence")
          .attr("x", 0).attr("y", 140);
        textbox.append("rect")
          .attr("fill", "#FDE79A")
          .attr("x", 0)
          .attr("y", 150)
          .attr("width", 10)
          .attr("height", 10)
        textbox.append("rect")
          .attr("fill", "#FEC26D")
          .attr("x", 0)
          .attr("y", 170)
          .attr("width", 10)
          .attr("height", 10)
        textbox.append("text").text("At least one does")
          .attr("x", 20).attr("y", 160).attr("font-size", "12px");
        textbox.append("text").text("Fully Vaccinated")
          .attr("x", 20).attr("y", 180).attr("font-size", "12px");
        var twoPi = 2 * Math.PI,
          formatPercent = d3.format(".0%");
        var arc = d3.arc()
          .startAngle(0)
          .innerRadius(0)
          .outerRadius(66);
        var arc2 = d3.arc()
          .startAngle(2 * Math.PI * 0.01)
          .innerRadius(0)
          .outerRadius(60);
        var meter = textbox.append("g")
          .attr("transform", "translate(" + 130 + "," + 260 + ")");
        meter.append("path")
          .attr("class", "pie-background")
          .attr("d", arc.endAngle(twoPi));
        var foreground = meter.append("path")
          .attr("class", "foreground");
        var foreground2 = meter.append("path")
          .attr("class", "foreground2");
        foreground.attr("d", arc.endAngle(twoPi * ((onepren + 0.01) / 100)));
        foreground2.attr("d", arc2.endAngle(twoPi * ((twopren + 0.01) / 100)));
        textbox.append("text").text(oneprenText)
          .attr("x", 200).attr("y", 270).attr("font-size", "12px");
        textbox.append("text").text(twoprenText)
          .attr("x", 170).attr("y", 205).attr("font-size", "12px");
      }
      // Event handler 2: Update mouse over for map
      let tooltipWidth = 130;
      let tooltipHeight = 40;
      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");
      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2);
      let txt2 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 22);
      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .attr("d", "");

      function mouseEntersPlot(d) {
        tooltip.style("visibility", "visible");
        let state = d3.select(d);
        let stateID = state.datum().id;
        console.log(state.datum())

        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === stateID || b.id === stateID; });
        momesh.datum(mo).attr("d", path)
        txt.text(idToState[stateID]);
        txt2.text(`vaccine rate: ${format(percentData[idToState[stateID]])}%`)
        let bounds = path.bounds(state.datum());
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1];
        tooltip.attr("transform", `translate(${xPos},${yPos})`);
      }
      function mouseLeavesPlot(d) {
        tooltip.style("visibility", "hidden");
        let state = d3.select(d);
        momesh.attr("d", "");
      }

      // Mouse over handling
      circles.on("mouseover", function (d) {
        // invoke lollipop chart handler & sizing circle
        // if (optionLollipop !== "sortPVI")
        //mouseover.attr("visibility", "");
        d3.select(this).transition().duration(200)
          .attr("r", 10)
          .attr("stroke-width", 4);
        updateMouseover(d3.select(this).datum())
        // invoke map handler
        let stateName = d3.select(this).datum().State;
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseEntersPlot(this);
          }
        })
      });

      circles.on("mouseout", function () {
        // invoke lollipop chart handler & sizing circle
        //mouseover.attr("visibility", "hidden");
        d3.select(this).transition().duration(200)
          .attr("r", 6)
          .attr("stroke-width", 1);
        let stateName = d3.select(this).datum().State;
        // invoke map handler
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseLeavesPlot(this);
          }
        })
      });
      rec.on("mouseover", function (d) {
        // invoke lollipop chart handler & sizing circle
        // if (optionLollipop !== "sortPVI")
        //mouseover.attr("visibility", "");
        updateMouseover(d3.select(this).datum())
        let stateName = d3.select(this).datum().State;
        let circleTarget = d3.select(`circle#${stateName}`);
        circleTarget.transition().duration(200)
          .attr("r", 10)
          .attr("stroke-width", 4);
        // invoke map handler
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseEntersPlot(this);
          }
        })
      });

      rec.on("mouseout", function () {
        // invoke lollipop chart handler & sizing circle
        //mouseover.attr("visibility", "hidden");
        let stateName = d3.select(this).datum().State;
        let circleTarget = d3.select(`circle#${stateName}`);
        circleTarget.transition().duration(200)
          .attr("r", 6)
          .attr("stroke-width", 1);
        // invoke map handler
        state.each(function () {
          let element = d3.select(this).datum()
          if (stateName == idToState[element.id]) {
            mouseLeavesPlot(this);
          }
        })
      });

      state.on("mouseenter", function (d) {
        // invoke map handler
        mouseEntersPlot(this);
        // invoke lollipop chart handler & sizing circle
        // if (optionLollipop !== "sortPVI")
        mouseover.attr("visibility", "");
        let ID = d3.select(this).datum().id;
        circles.each(function () {
          let element = d3.select(this).datum()
          if (element.State == idToState[ID]) {
            updateMouseover(element);
            d3.select(this).transition().duration(200)
              .attr("r", 10)
              .attr("stroke-width", 4);
          }
        })
      });
      state.on("mouseout", function (d) {
        // invoke map handler
        mouseLeavesPlot(this);
        let ID = d3.select(this).datum().id;
        // invoke lollipop chart handler & sizing circle
        //mouseover.attr("visibility", "hidden");
        circles.each(function () {
          let element = d3.select(this).datum()
          if (element.State == idToState[ID]) {
            d3.select(this).transition().duration(200)
              .attr("r", 6)
              .attr("stroke-width", 1);
          }
        })
      });

      let optionLollipop = "sortDosePrecent";
      // Dealing with sorting options for lollipop chart
      d3.select("#sort-select").on("change", function () {
        var option = d3.select(this).property("value")
        optionLollipop = option;
        var data;
        if (option === "sortPVI") {
          merge_data.sort((a, b) => d3.descending(a['pvi'], b['pvi']))
          //merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop with at least One Dose by State of Residence'], b['Percent of Total Pop with at least One Dose by State of Residence']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
          leftAxis.scale(dosesScale).tickFormat(function (d) { return d + "%"; });
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence']));

          // const pviExtent = d3.extent(merge_data, d => d['pvi']);
          // console.log(pviExtent)
          // const avgPvi = 0; //d3.mean(merge_data, d => d['pvi']);
          // const pviDist = Math.max(Math.abs(pviExtent[0] - avgPvi), Math.abs(pviExtent[1] - avgPvi));
          //
          // const adjustedPviExtent = [avgPvi - pviDist, avgPvi + pviDist];
          // const pviScale = d3.scaleLinear().domain(adjustedPviExtent).range([chartHeight, 0]);
          // data = merge_data;
          // console.log(merge_data)
          // newCodes = d3.map(data, d => d.Code)
          // codeScale.domain(newCodes);
          // bottomAxis.scale(codeScale);
          // bottomAxisG.transition().call(bottomAxis);
          // leftAxis.scale(pviScale).tickFormat(d3.format("~f"));
          // leftAxisG.transition().call(leftAxis);
          //
          // midline.attr("x1", 0).attr("x2", chartWidth + 10)
          //   .attr("y1", pviScale(avgPvi)).attr("y2", pviScale(avgPvi));
          // circles.attr("transform", d => `translate(${codeScale(d.Code)},${pviScale(d['pvi'])})`);
          // rec.attr("x", d => codeScale(d.Code) - 10)
          //   .attr("y", d => Math.min(pviScale(avgPvi), pviScale(d['pvi'])))
          //   .attr("height", d => Math.abs(pviScale(avgPvi) - pviScale(d['pvi'])))
          // lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
          //   .attr("y1", pviScale(avgPvi)).attr("y2", d => pviScale(d['pvi']));
        }
        // if (option === "sortAlpha") {
        //   merge_data.sort((a, b) => d3.ascending(a['State'], b['State']));
        //   data = merge_data;
        //   const pviExtent = d3.extent(merge_data, d => d['pvi']);
        //   console.log(pviExtent)
        //   const avgPvi = 0; //d3.mean(merge_data, d => d['pvi']);
        //   const pviDist = Math.max(Math.abs(pviExtent[0] - avgPvi), Math.abs(pviExtent[1] - avgPvi));

        //   const adjustedPviExtent = [avgPvi - pviDist, avgPvi + pviDist];
        //   const pviScale = d3.scaleLinear().domain(adjustedPviExtent).range([chartHeight, 0]);
        //   console.log(merge_data)
        //   newCodes = d3.map(data, d => d.Code)
        //   codeScale.domain(newCodes);
        //   bottomAxis.scale(codeScale);
        //   bottomAxisG.transition().call(bottomAxis);
        //   leftAxis.scale(pviScale).tickFormat(d3.format("~f"));
        //   leftAxisG.transition().call(leftAxis);

        //   midline.attr("x1", 0).attr("x2", chartWidth + 10)
        //     .attr("y1", pviScale(avgPvi)).attr("y2", pviScale(avgPvi));
        //   circles.attr("transform", d => `translate(${codeScale(d.Code)},${pviScale(d['pvi'])})`);
        //   rec.attr("x", d => codeScale(d.Code) - 10)
        //     .attr("y", d => Math.min(pviScale(avgPvi), pviScale(d['pvi'])))
        //     .attr("height", d => Math.abs(pviScale(avgPvi) - pviScale(d['pvi'])))
        //   lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
        //     .attr("y1", pviScale(avgPvi)).attr("y2", d => pviScale(d['pvi']));
        // }
        else if (option === "sortTotalDose") {
          merge_data.sort((a, b) => d3.ascending(a['Total Doses Delivered'], b['Total Doses Delivered']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Total Doses Delivered']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLog().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Total Doses Delivered']);

          leftAxis.scale(dosesScale).tickFormat(d3.format(".2s"));
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Total Doses Delivered'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Total Doses Delivered'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Total Doses Delivered'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Total Doses Delivered']));

        }
        else if (option === "sortDosePrecent") {
          merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop with at least One Dose by State of Residence'], b['Percent of Total Pop with at least One Dose by State of Residence']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Percent of Total Pop with at least One Dose by State of Residence']);
          leftAxis.scale(dosesScale).tickFormat(function (d) { return d + "%"; });
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop with at least One Dose by State of Residence']));
        }
        else if (option === "sortDosePrecentTwo") {
          merge_data.sort((a, b) => d3.ascending(a['Percent of Total Pop Fully Vaccinated by State of Residence'], b['Percent of Total Pop Fully Vaccinated by State of Residence']));
          data = merge_data;
          console.log(merge_data);
          dosesExten = d3.extent(data, d => d['Percent of Total Pop Fully Vaccinated by State of Residence']);
          console.log(dosesExten)
          const dosesScale = d3.scaleLinear().domain(dosesExten).range([chartHeight, 0]);
          newCodes = d3.map(data, d => d.Code)
          codeScale.domain(newCodes);
          bottomAxis.scale(codeScale);
          bottomAxisG.transition().call(bottomAxis)

          const avgDose = d3.mean(merge_data, d => d['Percent of Total Pop Fully Vaccinated by State of Residence']);
          leftAxis.scale(dosesScale).tickFormat(function (d) { return d + "%"; });
          leftAxisG.transition().call(leftAxis);
          midline.attr("x1", 0).attr("x2", chartWidth + 10)
            .attr("y1", dosesScale(avgDose)).attr("y2", dosesScale(avgDose));
          circles.attr("transform", d => `translate(${codeScale(d.Code)},${dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence'])})`);
          rec.attr("x", d => codeScale(d.Code) - 10)
            .attr("y", d => Math.min(dosesScale(avgDose), dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence'])))
            .attr("height", d => Math.abs(dosesScale(avgDose) - dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence'])))
          lines.attr("x1", d => codeScale(d.Code)).attr("x2", d => codeScale(d.Code))
            .attr("y1", dosesScale(avgDose)).attr("y2", d => dosesScale(d['Percent of Total Pop Fully Vaccinated by State of Residence']));
        }

      })

      // Dealing with sorting options for map
      d3.select("#options").on("change", function () {
        var option = d3.select(this).property("value")
        console.log(option)
        var data;
        if (option === "pviValue") {
          optionControl = "pviValue";
          // update legend
          document.querySelector('div.legend1').innerText = "Cook Partisan Voting Index By State (same scale as above)";
          d3.select("svg#map-legend-red").attr("visibility", "hidden");
          d3.select("svg#map-legend-blue").attr("visibility", "hidden");
          // update color
          updateFilter(numControl);
        }
        else if (option === "vaccineValue") {
          optionControl = "vaccineValue";
          // update color for map
          updateFilter(numControl);
          // update legend
          document.querySelector('div.legend2').innerText = "Precent of Total Pop with at least One Dose(%)";
          d3.select("svg#map-legend-red").attr("visibility", "hidden");
          d3.select("svg#map-legend-blue").attr("visibility", "");
          const legendPurple = d3.legendColor()
            .shapeWidth(200)
            .cells(10)
            .orient('horizontal')
            .scale(colorScale);
          blueLine.call(legendPurple);
        }
        else if (option === "vaccineByPolitic") {
          optionControl = "vaccineByPolitic";
          // update color
          updateFilter(numControl);
          // update legend
          document.querySelector('div.legend2').innerText = "Precent of Total Pop with at least One Dose(%)";
          d3.select("svg#map-legend-red").attr("visibility", "");
          d3.select("svg#map-legend-blue").attr("visibility", "");
          blueLine.call(legendBlue);
        }
      })

      // Do some counting for user
      let redNumTotal = 0;
      let blueNumTotal = 0;
      merge_data.forEach((d, i) => {
        if (d.pvi < 0) blueNumTotal = blueNumTotal + 1;
        else if (d.pvi > 0) redNumTotal = redNumTotal + 1;
      })
      let optionControl = "vaccineByPolitic";
      let numControl = 23;
      // update color for map with filter
      function updateFilter(num) {
        let redNum = 0;
        let blueNum = 0;
        // update label for counting result
        document.querySelector('b#chosenNum').innerText = `${num}`;
        merge_data.forEach((d, i) => {
          if (d['Percent of Total Pop with at least One Dose by State of Residence'] > num) {
            if (d.pvi < 0) blueNum = blueNum + 1;
            else if (d.pvi > 0) redNum = redNum + 1;
          }
          document.querySelector('div#blueNum').innerText = `Number of Democratic states: ${blueNum}`;
          document.querySelector('div#redNum').innerText = `Number of Republican states: ${redNum}`;
          document.querySelector('div#bluePercent').innerText = `Percent of Democratic states: ${format(100 * blueNum / (blueNumTotal + redNumTotal))} %`;
          document.querySelector('div#redPercent').innerText = `Percent of Republican states: ${format(100 * redNum / (redNumTotal + blueNumTotal))} %`;
          document.querySelector('b#range').innerText = `with vaccination rate over ${num}%`;
        })
        // update color based on options of map
        // case 1
        if (optionControl === "vaccineByPolitic") {
          state.style("fill", d => {
            if (percentData[idToState[d.id]] < num) return "#ffffff";
            if (percentData[idToState[d.id]] == 0) return "#ffffff";
            else if (pviData[idToState[d.id]] < 0) return blueScale(percentData[idToState[d.id]]);
            else if (pviData[idToState[d.id]] > 0) return redScale(percentData[idToState[d.id]]);
            else return "gray";
          });
        }
        // case 2
        else if (optionControl === "vaccineValue") {
          state.style("fill", d => {
            if (percentData[idToState[d.id]] < num) return "#ffffff";
            else return colorScale(percentData[idToState[d.id]]);
          });
        }
        // case 3
        else if (optionControl === "pviValue") {
          state.style("fill", d => {
            if (percentData[idToState[d.id]] < num) return "#ffffff";
            let pviValue = pviData[idToState[d.id]];
            if (pviValue <= -10) {
              return "#2874A6";
            } else if (pviValue <= -3) {
              return "#3498DB";
            }
            else if (pviValue < 0) {
              return "#AED6F1";
            } else if (pviValue >= 17) {
              return "#B03A2E";
            } else if (pviValue >= 11) {
              return "#E74C3C";
            } else if (pviValue > 0) {
              return "#F5B7B1";
            }
            else {
              return "#ABB2B9";
            }
          })
        }

      }
      updateFilter(23);
      // filter input handler
      const input = document.querySelector('input');
      const log = document.getElementById('volume');
      input.addEventListener('input', updateValue);
      function updateValue(evt) {
        // console.log(log.valueAsNumber);
        numControl = log.valueAsNumber;
        // update color
        updateFilter(log.valueAsNumber);
      }
    }

    requestData();
  </script>

</body>

</html>